import cv2
import numpy as np

# Get user supplied values
imagePath = "collected-images/images/" + "10.jpg"

testCascPath = "haarcascades/" + "fist.xml"

palmCascPath = "haarcascades/" + "palm.xml"  # 20, 85,85 (DONE)
eyePairBigPath = "haarcascades/" + "eyePairBig.xml"  # 20, 30,30 (DONE)
mouthCascPath = "haarcascades/" + "mouth.xml"  ###80, 60,60 (DONE)
upperBodyCascPath = "haarcascades/" + "upperBody.xml"  # 50, 500,500 (DONE)
noseCascPath = "haarcascades/" + "nose.xml"  ###80, 60,60 (DONE)
fullBodyCascPath = "haarcascades/" + "fullBody.xml"  ###1, 60,60 (DONE)
faceCascPath = (
    "haarcascades/" + "haarcascade_frontalface_default.xml"
)  # 25, 60,60 (DONE)
fistCascPath = "haarcascades/" + "fist.xml"  # 20 85,85 (DONE)


# Create the haar cascades
testCascade = cv2.CascadeClassifier(testCascPath)

palmCascade = cv2.CascadeClassifier(palmCascPath)
eyePairCascade = cv2.CascadeClassifier(eyePairBigPath)
mouthCascade = cv2.CascadeClassifier(mouthCascPath)
upperBodyCascade = cv2.CascadeClassifier(upperBodyCascPath)
noseCascade = cv2.CascadeClassifier(noseCascPath)
fullBodyCascade = cv2.CascadeClassifier(fullBodyCascPath)
faceCascade = cv2.CascadeClassifier(faceCascPath)
fistCascade = cv2.CascadeClassifier(fistCascPath)

cascs = {
    "palm": palmCascade,
    "eyePair": eyePairCascade,
    "mouth": mouthCascade,
    "upperBody": upperBodyCascade,
    "nose": noseCascade,
    "fullBody": fullBodyCascade,
    "faceCascade": faceCascade,
    "fistCascade": fistCascade,
}

# list of minNeighbors
minNeighbors = {
    "palm": 20,
    "eyePair": 20,
    "mouth": 80,
    "upperBody": 50,
    "nose": 80,
    "fullBody": 1,
    "faceCascade": 25,
    "fistCascade": 20,
}  # 92

minSize = {
    "palm": (85, 85),
    "eyePair": (30, 30),
    "mouth": (60, 60),
    "upperBody": (500, 500),
    "nose": (60, 60),
    "fullBody": (60, 60),
    "faceCascade": (60, 60),
    "fistCascade": (85, 85),
}  # 92

colours = {
    "palm": (255, 0, 0),
    "eyePair": (0, 255, 0),
    "mouth": (0, 0, 255),
    "upperBody": (255, 255, 0),
    "nose": (0, 255, 255),
    "fullBody": (255, 0, 255),
    "faceCascade": (255, 255, 255),
    "fistCascade": (120, 50, 200),
}

# stores lists of rectangles generated by detectMultiScale
rectsList = {
    "palm": None,
    "eyePair": None,
    "mouth": None,
    "upperBody": None,
    "nose": None,
    "fullBody": None,
    "faceCascade": None,
    "fistCascade": None,
}

# display an image
def display_cv_image(image):
    scale_percent = 20  # percent of original size
    width = int(image.shape[1] * scale_percent / 100)
    height = int(image.shape[0] * scale_percent / 100)
    dim = (width, height)
    # resize image
    resized = cv2.resize(image, dim, interpolation=cv2.INTER_AREA)
    cv2.imshow("Image", resized)


# Read the image
image = cv2.imread(imagePath)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)


# Check Readiness

# queue, order of checking readiness, goal is to detect eyePair
checkReady = ["fullBody", "upperBody", "eyePair"]
checkImage = cv2.imread(imagePath)
checkGrayIm = cv2.imread(imagePath, cv2.COLOR_BGR2GRAY)
# change to false to now draw rectangles
drawRectangles = True
# concern will be over written to equal the part to indicate the point of failure
concern = False

# create a new offset tracker
offset = [0, 0]

for part in checkReady:
    # use part as a key to casc dictionary
    cascade = cascs[part]
    # apply the cascade and generate all the 'rectangles'
    rects = cascade.detectMultiScale(
        checkGrayIm,
        scaleFactor=1.05,
        minNeighbors=minNeighbors[part],
        minSize=minSize[part],
    )

    # error check to make sure only 1 of the part is found
    if len(rects) != 1:
        # update concern
        concern = part
        # temporary
        print("{} Not Found".format(part))
        break
    # draw rectangles
    elif drawRectangles:
        for (x, y, w, h) in rects:
            # offset the rectangles by the right amount
            x += offset[0]
            y += offset[1]
            cv2.rectangle(checkImage, (x, y), (x + w, y + h), colours[part], 2)
    # crop down the image
    (x, y, w, h) = rects[0]

    # update crop offset
    offset[0] += x
    offset[1] += y

    checkGrayIm = checkGrayIm[y : y + h, x : x + w].copy()
    # store the found rectangles
    rectsList[part] = rects[0]

# Indicate Readiness
if not concern:
    print("Completed Readiness Check Successfully!")
else:
    print("User is not Ready!")

# Hand Detection with Glove Detection
# the assumption is the rect for fullbody exist from readiness check
checkHand = ["palm"]  # conside checking fists
(x, y, w, h) = rectsList["fullBody"]
handIm = image[y : y + h, x : x + w].copy()
concern = False
offset = [0, 0]
# update crop offset since we need to adjust for it when drawing rects
offset[0] += x
offset[1] += y
for part in checkHand:
    # obtain cascade and detect the part
    cascade = cascs[part]
    rects = cascade.detectMultiScale(
        handIm, scaleFactor=1.05, minNeighbors=minNeighbors[part], minSize=minSize[part]
    )
    if len(rects) != 2:
        print("Detected {} {}.".format(len(rects), part))
        concern = True
        pass
    if drawRectangles:
        for (x, y, w, h) in rects:
            # offset the rectangles by the right amount
            x += offset[0]
            y += offset[1]
            cv2.rectangle(checkImage, (x, y), (x + w, y + h), colours[part], 2)
    # store the found hands
    rectsList[part] = rects
    missingGlove = 0
    for hand in rects:
        (x, y, w, h) = hand
        singleHandIm = hsv[y : y + h, x : x + w].copy()
        # glove detection
        lowerRange = np.array([177, 0, 0])
        upperRange = np.array([212, 255, 255])
        gloveMask = cv2.inRange(singleHandIm, lowerRange, upperRange)
        (mean_hue, a, b, c) = cv2.mean(gloveMask)
        if mean_hue < 50:  # Value TBD
            missingGlove += 1
    print("Missing {} Gloves".format(missingGlove))
    break
if not concern:
    print("2 Hands are Detected!")

else:
    print("2 Hands not Detected!")


# check for Gown
(x, y, w, h) = rectsList["fullBody"]
upperIm = hsv[y : y + h, x : x + w].copy()
lowerRange = np.array([15, 0, 0])
upperRange = np.array([36, 255, 255])
gownMask = cv2.inRange(upperIm, lowerRange, upperRange)
(mean_hue, a, b, c) = cv2.mean(gloveMask)
if mean_hue < 70:  # Value TBD
    print("Missing gown!")
else:
    print("Gown is present!")


# Face Detection + Mask
# use existing upper body to obtain face and mouth identification
(x, y, w, h) = rectsList["upperBody"]
checkMask = gray[y : y + h, x : x + w].copy()
obtain = ["faceCascade", "mouth"]
offset = [0, 0]
offset[0] += x
offset[1] += y
for part in obtain:
    cascade = cascs[part]
    rects = cascade.detectMultiScale(
        checkMask,
        scaleFactor=1.05,
        minNeighbors=minNeighbors[part],
        minSize=minSize[part],
    )
    N = len(rects)
    if part == "mouth":
        if N == 1:
            print("Mouth found!")
        elif N == 0:
            print("No mouth found!")
        else:
            print("{} Mouths found".format(N))
    elif part == "faceCasade":
        if N != 1:
            print("Amount of faces is not 1! Cannot proceed to check for a mouth.")
            break
    if drawRectangles:
        for (x, y, w, h) in rects:
            # offset the rectangles by the right amount
            x += offset[0]
            y += offset[1]
            cv2.rectangle(checkImage, (x, y), (x + w, y + h), colours[part], 2)
    # crop down the image
    (x, y, w, h) = rects[0]

    # update crop offset
    offset[0] += x
    offset[1] += y

    checkMask = checkMask[y : y + h, x : x + w].copy()
    # store the found rectangles
    rectsList[part] = rects[0]


display_cv_image(checkImage)

cv2.waitKey(0)
